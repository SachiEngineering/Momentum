'''
Given a 3x3 lock screen in the following arrangement:

1 2 3
4 5 6
7 8 9

count the total number of unlock patterns that use N numbers.

A pattern is valid if the following criteria are met:
- no number is used more than once
- a path from one number to another does not directly pass through an unused number. eg:
  - 2 -> 1 -> 3 is valid, but 1 -> 3 is not valid because it directly passes through the unused number 2

NOTE: It is possible to go from 2 to 9 (or 3 to 4) because the pattern may move between rows and colunns on diagonals.
 

EXAMPLE(S)
1 2 3
4 5 6
7 8 9

4 -> 1 -> 3 -> 6 is invalid because 1 -> 3 passes through the unused 2

2 -> 4 -> 1 -> 3 -> 6 is valid
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 is valid
 

FUNCTION SIGNATURE
function countPatterns(numberOfKeys) {
def countPatterns(numberOfKeys: int) -> int:


Explore:
- n < 1 is invalid
- n > 9 is invalid



Brainstorm:
Approach:
- visited array
- which are invalid jumps
1,3. || 3,1 -> 2
1,7 || 7,1 -> 4
1,9 || 9,1 -> 5
2,8 || 8,2 -> 5
3,9 || 9,3 -> 6
3,7 || 7,3
4,6 || 6,4
7,9 || 9,7

[][]
{'1,3': 2}
{'3,1': 2}

EXAMPLE(S)
1 2 3
4 5 6
7 8 9

- func (start , end , visited) - returns if this is a valid jump
- isValid : either it's not in this list or if the number between is already used(visited)


Plan:



'''
def countPatterns(numberOfKeys: int) -> int:
    # If the number of keys is less than 1 or greater than 9, no valid pattern exists
    if numberOfKeys < 1 or numberOfKeys > 9:
        return 0

    # Skipped numbers between two numbers when the center point has to be used
    skip = [[0] * 10 for _ in range(10)]
    skip[1][3] = skip[3][1] = 2
    skip[1][7] = skip[7][1] = 4
    skip[3][9] = skip[9][3] = 6
    skip[7][9] = skip[9][7] = 8
    skip[1][9] = skip[9][1] = 5
    skip[2][8] = skip[8][2] = 5
    skip[3][7] = skip[7][3] = 5
    skip[4][6] = skip[6][4] = 5
    
    def dfs(visited, cur, remainingKeys):
        if remainingKeys == 0:
            return 1  # A valid pattern is found if no more keys are remaining
        visited[cur] = True
        count = 0
        for i in range(1, 10):
            # Continue if the number is not visited and either there's no skip or the skipped number is visited
            if not visited[i] and (skip[cur][i] == 0 or visited[skip[cur][i]]):
                count += dfs(visited, i, remainingKeys - 1)
        visited[cur] = False
        return count

    # Total number of valid patterns
    totalPatterns = 0
    visited = [False] * 10
    

# 1 2 3
# 4 5 6
# 7 8 9
    # We calculate for each unique starting position: 1, 2, 5
    # 1, 3, 7, 9 are symmetric
    totalPatterns += dfs(visited, 1, numberOfKeys - 1) * 4  # Starting from 1, 3, 7, 9 (symmetrical)
    totalPatterns += dfs(visited, 2, numberOfKeys - 1) * 4  # Starting from 2, 4, 6, 8 (symmetrical
    totalPatterns += dfs(visited, 5, numberOfKeys - 1)      # Starting from 5 (center, unique)
    
    return totalPatterns

# Example usage:
print(countPatterns(1))  # Should return 9, as there are 9 different patterns of length 1 (just the digits themselves)
print(countPatterns(2))  # Should return a number representing all possible 2-key patterns
print(countPatterns(3))  # Should return a number representing all possible 3-key patterns
    
